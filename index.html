<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sudanese Chess - Designed by Ahmed Gallal √Çƒú</title>
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@700&display=swap" rel="stylesheet" />
  <style>
    :root {
      --white: #eeeed2; --black: #769656; --night-white: #444;
      --night-black: #222; --night-text: #eee;
      --hint-color: rgba(0, 0, 255, 0.3);
    }
    body {
      margin: 0; padding: 0;
      font-family: 'Cairo', sans-serif;
      background-color: var(--white);
      color: #000;
      display: flex; flex-direction: column;
      align-items: center; justify-content: flex-start;
      min-height: 100vh;
      transition: all 0.3s ease;
    }
    h1 { margin: 10px 0 5px; font-size: 32px; color: #222; }
    #dedication { font-size: 18px; margin-bottom: 5px; color: #555; }
    #version { font-size: 14px; color: #888; margin-bottom: 10px; }
    #turnInfo { margin: 5px; font-weight: bold; }
    #timers {
      font-size: 14px; margin-bottom: 5px; color: #333;
    }
    select { margin: 5px; padding: 4px; font-size: 14px; }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 60px);
      grid-template-rows: repeat(8, 60px);
      border: 3px solid #333;
      margin-bottom: 10px;
    }
    .cell {
      width: 60px; height: 60px;
      display: flex; align-items: center;
      justify-content: center;
      font-size: 32px;
      cursor: pointer;
      position: relative;
      user-select: none;
    }
    .white { background-color: var(--white); }
    .black { background-color: var(--black); }
    .night .white { background-color: var(--night-white); }
    .night .black { background-color: var(--night-black); }
    .selected { outline: 3px solid red; }
    .hint {
      background-color: var(--hint-color);
      position: absolute;
      top: 3px; left: 3px; right: 3px; bottom: 3px;
      border-radius: 10px;
      pointer-events: none;
    }
    #controls {
      margin: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      padding: 5px 12px;
      font-size: 14px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      user-select: none;
    }
    .night { background-color: #111; color: var(--night-text); }
    footer { margin: 20px; font-size: 14px; }
  </style>
</head>
<body>
  <h1>Designed by Ahmed Gallal √Çƒú</h1>
  <div id="dedication">First version dedicated to Hosh Almuna</div>
  <div id="version">Version 1 - 2025</div>

  <div id="turnInfo">Turn: White</div>
  <div id="timers">
    ‚è±Ô∏è White Time: <span id="whiteTimer">05:00</span> |
    ‚è±Ô∏è Black Time: <span id="blackTimer">05:00</span>
  </div>

  <select id="gameMode" onchange="resetGame()">
    <option value="human">üßë Play with Person</option>
    <option value="ai-easy">ü§ñ AI (Easy)</option>
    <option value="ai-hard">üß† AI (Hard)</option>
  </select>

  <div class="board" id="chessboard"></div>

  <div id="controls">
    <button onclick="undoMove()">Undo</button>
    <button onclick="toggleNightMode()">Night Mode</button>
    <button onclick="resetGame()">Reset</button>
  </div>

  <footer>Made with ‚ù§Ô∏è by Ahmed Gallal √Çƒú</footer>

  <script>
    const moveSound = new Audio('https://upload.wikimedia.org/wikipedia/commons/8/88/Chess_move.wav');

    const board = document.getElementById("chessboard");
    const turnInfo = document.getElementById("turnInfo");
    const gameModeSelect = document.getElementById("gameMode");
    const whiteTimerEl = document.getElementById("whiteTimer");
    const blackTimerEl = document.getElementById("blackTimer");

    const pieceIcons = {
      'wp': '‚ôô', 'wr': '‚ôñ', 'wn': '‚ôò', 'wb': '‚ôó', 'wq': '‚ôï', 'wk': '‚ôî',
      'bp': '‚ôüÔ∏é', 'br': '‚ôú', 'bn': '‚ôû', 'bb': '‚ôù', 'bq': '‚ôõ', 'bk': '‚ôö'
    };

    let boardState = [];
    let selected = null;
    let currentTurn = 'w';
    let moveHistory = [];
    let whiteTime = 300, blackTime = 300;
    let timerInterval;
    let aiThinking = false;

    function setupBoard() {
      const layout = [
        ['br','bn','bb','bq','bk','bb','bn','br'],
        Array(8).fill('bp'),
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        Array(8).fill('wp'),
        ['wr','wn','wb','wq','wk','wb','wn','wr']
      ];
      board.innerHTML = '';
      boardState = layout.map(row => [...row]);
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell ' + ((r + c) % 2 === 0 ? 'white' : 'black');
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.textContent = pieceIcons[layout[r][c]] || '';
          cell.onclick = () => onCellClick(r, c);
          board.appendChild(cell);
        }
      }
    }

    function onCellClick(r, c) {
      if (aiThinking) return; // Prevent interaction during AI turn
      const piece = boardState[r][c];
      const cell = getCell(r, c);

      if (selected) {
        const [fromR, fromC] = selected;
        const selectedPiece = boardState[fromR][fromC];
        if (canMove(selectedPiece, fromR, fromC, r, c)) {
          moveSound.play();
          moveHistory.push(JSON.parse(JSON.stringify(boardState)));
          boardState[r][c] = boardState[fromR][fromC];
          boardState[fromR][fromC] = '';
          // Pawn promotion
          if (boardState[r][c][1] === 'p' && (r === 0 || r === 7)) {
            boardState[r][c] = currentTurn + 'q';
          }
          updateBoard();
          if (isCheckmate(opponent())) {
            setTimeout(() => alert('Checkmate! Game over!'), 200);
          }
          currentTurn = opponent();
          turnInfo.textContent = `Turn: ${currentTurn === 'w' ? 'White' : 'Black'}`;
          startTimer();
          clearSelection();
          selected = null;

          if (gameModeSelect.value.startsWith('ai') && currentTurn === 'b') {
            aiThinking = true;
            setTimeout(() => {
              makeAIMove();
              aiThinking = false;
            }, 300);
          }
          return;
        }
        clearSelection();
        selected = null;
      }
      if (piece && piece[0] === currentTurn) {
        clearSelection();
        selected = [r, c];
        cell.classList.add('selected');
        showHints(r, c);
      }
    }

    function getCell(r, c) {
      return board.children[r * 8 + c];
    }

    function clearSelection() {
      document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected', 'hint'));
    }

    function showHints(fr, fc) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (canMove(boardState[fr][fc], fr, fc, r, c)) {
            getCell(r, c).classList.add('hint');
          }
        }
      }
    }

    function updateBoard() {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          getCell(r, c).textContent = pieceIcons[boardState[r][c]] || '';
        }
      }
    }

    function opponent() {
      return currentTurn === 'w' ? 'b' : 'w';
    }

    function canMove(piece, fr, fc, tr, tc) {
      if (!piece) return false;
      const target = boardState[tr][tc];
      if (target && target[0] === piece[0]) return false;
      const dr = tr - fr;
      const dc = tc - fc;
      const absR = Math.abs(dr);
      const absC = Math.abs(dc);

      switch (piece[1]) {
        case 'p': {
          const dir = piece[0] === 'w' ? -1 : 1;
          // Move forward
          if (dc === 0 && !target) {
            if (dr === dir) return true;
            if ((fr === (piece[0] === 'w' ? 6 : 1)) && dr === 2 * dir && !boardState[fr + dir][fc]) return true;
          } else if (absC === 1 && dr === dir && target && target[0] !== piece[0]) {
            return true;
          }
          return false;
        }
        case 'r':
          return (dr === 0 || dc === 0) && clearPath(fr, fc, tr, tc);
        case 'b':
          return absR === absC && clearPath(fr, fc, tr, tc);
        case 'q':
          return (dr === 0 || dc === 0 || absR === absC) && clearPath(fr, fc, tr, tc);
        case 'k':
          return absR <= 1 && absC <= 1;
        case 'n':
          return (absR === 2 && absC === 1) || (absR === 1 && absC === 2);
      }
      return false;
    }

    function clearPath(fr, fc, tr, tc) {
      const stepR = Math.sign(tr - fr);
      const stepC = Math.sign(tc - fc);
      let r = fr + stepR;
      let c = fc + stepC;
      while (r !== tr || c !== tc) {
        if (boardState[r][c]) return false;
        r += stepR;
        c += stepC;
      }
      return true;
    }

    function isCheckmate(color) {
      // Simple check: if king is missing, it's checkmate
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (boardState[r][c] === color + 'k') return false;
        }
      }
      return true;
    }

    function undoMove() {
      if (moveHistory.length > 0) {
        boardState = moveHistory.pop();
        currentTurn = opponent();
        updateBoard();
        turnInfo.textContent = `Turn: ${currentTurn === 'w' ? 'White' : 'Black'}`;
        startTimer();
      }
    }

    function toggleNightMode() {
      document.body.classList.toggle('night');
    }

    function resetGame() {
      setupBoard();
      moveHistory = [];
      currentTurn = 'w';
      whiteTime = 300;
      blackTime = 300;
      updateTimers();
      turnInfo.textContent = `Turn: White`;
      clearSelection();
      startTimer();
    }

    function startTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (currentTurn === 'w') whiteTime--;
        else blackTime--;
        updateTimers();
        if (whiteTime <= 0 || blackTime <= 0) {
          clearInterval(timerInterval);
          alert(currentTurn

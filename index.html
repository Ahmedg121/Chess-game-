<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ø´Ø·Ø±Ù†Ø¬ Ø³ÙˆØ¯Ø§Ù†ÙŠ - ØªØµÙ…ÙŠÙ… Ø£Ø­Ù…Ø¯ Ø¬Ù„Ø§Ù„ Ã‚Äœ</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@700&display=swap');

    :root {
      --white: #eeeed2;
      --black: #769656;
      --night-white: #444;
      --night-black: #222;
      --night-text: #eee;
      --highlight-blue: rgba(30, 144, 255, 0.4);
    }
    body {
      margin: 0;
      padding: 0;
      font-family: 'Cairo', sans-serif;
      background-color: var(--white);
      color: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      min-height: 100vh;
      transition: all 0.3s ease;
    }
    h1 {
      margin: 10px 0 5px;
      font-size: 32px;
      color: #222;
    }
    #dedication {
      font-size: 18px;
      margin-bottom: 5px;
      color: #555;
    }
    #version {
      font-size: 14px;
      color: #888;
      margin-bottom: 15px;
    }
    #turnInfo { margin: 10px; font-weight: bold; }
    #timers {
      font-size: 14px;
      margin: 5px;
      color: #333;
      direction: rtl;
    }
    .board {
      display: grid;
      grid-template-columns: repeat(8, 55px);
      grid-template-rows: repeat(8, 55px);
      border: 3px solid #333;
      margin-bottom: 10px;
      user-select: none;
    }
    .cell {
      width: 55px;
      height: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 28px;
      cursor: pointer;
      position: relative;
      box-sizing: border-box;
    }
    .white { background-color: var(--white); }
    .black { background-color: var(--black); }
    .night .white { background-color: var(--night-white); }
    .night .black { background-color: var(--night-black); }
    .selected { outline: 3px solid red; }
    .highlight-move {
      position: absolute;
      top: 3px; left: 3px; right: 3px; bottom: 3px;
      background-color: var(--highlight-blue);
      border-radius: 10px;
      pointer-events: none;
      z-index: 1;
    }
    #controls { margin: 10px; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;}
    button, select {
      padding: 5px 12px;
      font-size: 14px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      background: #4a90e2;
      color: white;
      font-weight: bold;
      transition: background 0.3s ease;
    }
    button:hover, select:hover {
      background: #357ABD;
    }
    .night {
      background-color: #111;
      color: var(--night-text);
    }
    footer {
      margin: 20px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>Ù…Ù† ØªØµÙ…ÙŠÙ… Ahmed Gallal Ã‚Äœ</h1>
  <div id="dedication">Ø£ÙˆÙ„ Ù†Ø³Ø®Ø© Ù…Ù‡Ø¯Ø§Ø© Ø¥Ù„Ù‰ Ø­ÙˆØ´ Ø§Ù„Ù…Ù†Ø§</div>
  <div id="version">Ø¥ØµØ¯Ø§Ø± Ø£ÙˆÙ„ - 2025</div>

  <div>
    <label for="gameMode" style="font-weight:bold; margin-bottom:8px; display:block;">Ø§Ø®ØªØ± ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨:</label>
    <select id="gameMode" aria-label="ÙˆØ¶Ø¹ Ø§Ù„Ù„Ø¹Ø¨">
      <option value="human">ğŸ§‘ Ù„Ø¹Ø¨ Ù…Ø¹ Ø´Ø®Øµ</option>
      <option value="ai-easy">ğŸ¤– Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ (Ø³Ù‡Ù„)</option>
      <option value="ai-hard">ğŸ§  Ø°ÙƒØ§Ø¡ Ø§ØµØ·Ù†Ø§Ø¹ÙŠ (ØµØ¹Ø¨)</option>
    </select>
  </div>

  <div id="turnInfo">Ø§Ù„Ø¯ÙˆØ±: Ø§Ù„Ø£Ø¨ÙŠØ¶</div>
  <div id="timers">
    â±ï¸ ÙˆÙ‚Øª Ø§Ù„Ø£Ø¨ÙŠØ¶: <span id="whiteTimer">05:00</span>
    | â±ï¸ ÙˆÙ‚Øª Ø§Ù„Ø£Ø³ÙˆØ¯: <span id="blackTimer">05:00</span>
  </div>

  <div class="board" id="chessboard" aria-label="Ù„ÙˆØ­Ø© Ø´Ø·Ø±Ù†Ø¬"></div>
  <div id="controls">
    <button onclick="undoMove()">ØªØ±Ø§Ø¬Ø¹</button>
    <button onclick="toggleNightMode()">Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ù„ÙŠÙ„ÙŠ</button>
    <button onclick="resetGame()">Ø¥Ø¹Ø§Ø¯Ø©</button>
  </div>
  <footer>ØªØµÙ…ÙŠÙ… Ø£Ø­Ù…Ø¯ Ø¬Ù„Ø§Ù„ Ã‚Äœ - 2025</footer>

  <script>
    const board = document.getElementById("chessboard");
    const turnInfo = document.getElementById("turnInfo");
    const whiteTimerEl = document.getElementById("whiteTimer");
    const blackTimerEl = document.getElementById("blackTimer");
    const gameModeSelect = document.getElementById("gameMode");

    const pieceIcons = {
      'wp': 'â™™', 'wr': 'â™–', 'wn': 'â™˜', 'wb': 'â™—', 'wq': 'â™•', 'wk': 'â™”',
      'bp': 'â™Ÿï¸', 'br': 'â™œ', 'bn': 'â™', 'bb': 'â™', 'bq': 'â™›', 'bk': 'â™š'
    };
    
    let boardState = [];
    let selected = null;
    let currentTurn = 'w';
    let moveHistory = [];
    let whiteTime = 300, blackTime = 300;
    let timerInterval;
    let aiThinking = false;

    const moveSound = new Audio('https://upload.wikimedia.org/wikipedia/commons/8/88/Chess_move.wav');

    function setupBoard() {
      const layout = [
        ['br','bn','bb','bq','bk','bb','bn','br'],
        Array(8).fill('bp'),
        ...Array(4).fill(Array(8).fill('')),
        Array(8).fill('wp'),
        ['wr','wn','wb','wq','wk','wb','wn','wr']
      ];
      board.innerHTML = '';
      boardState = layout.map(row => [...row]);
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell ' + ((r + c) % 2 === 0 ? 'white' : 'black');
          cell.dataset.row = r;
          cell.dataset.col = c;
          cell.textContent = pieceIcons[layout[r][c]] || '';
          cell.onclick = () => onCellClick(r, c);
          board.appendChild(cell);
        }
      }
      clearSelection();
      selected = null;
      highlightMoves([]);
    }

    function onCellClick(r, c) {
      if (aiThinking) return;  // ØªÙ…Ù†Ø¹ Ø§Ù„Ù„Ø¹Ø¨ ÙÙŠ Ø¯ÙˆØ± AI

      const piece = boardState[r][c];
      const cell = getCell(r, c);

      if (selected) {
        const [fromR, fromC] = selected;
        const selectedPiece = boardState[fromR][fromC];
        if (canMove(selectedPiece, fromR, fromC, r, c)) {
          moveHistory.push(JSON.parse(JSON.stringify(boardState)));
          boardState[r][c] = boardState[fromR][fromC];
          boardState[fromR][fromC] = '';

          if (boardState[r][c][1] === 'p' && (r === 0 || r === 7)) {
            boardState[r][c] = currentTurn + 'q';
          }

          updateBoard();
          moveSound.play();

          if (isCheckmate(opponent())) {
            setTimeout(() => alert('Ø§Ø¨Ù„Ø¹ ÙŠØ§ Ø²ÙˆÙ„! ÙƒØ´ Ù…Ø§Øª!'), 200);
          }
          currentTurn = opponent();
          turnInfo.textContent = `Ø§Ù„Ø¯ÙˆØ±: ${currentTurn === 'w' ? 'Ø§Ù„Ø£Ø¨ÙŠØ¶' : 'Ø§Ù„Ø£Ø³ÙˆØ¯'}`;
          startTimer();

          selected = null;
          clearSelection();
          highlightMoves([]);

          if (gameModeSelect.value !== 'human' && currentTurn === 'b') {
            aiThinking = true;
            setTimeout(() => {
              if(gameModeSelect.value === 'ai-easy') makeEasyAIMove();
              else makeHardAIMove();
              aiThinking = false;
              startTimer();
            }, 600);
          }
        } else {
          clearSelection();
          selected = null;
          highlightMoves([]);
        }
      } else if (piece && piece[0] === currentTurn) {
        clearSelection();
        selected = [r, c];
        cell.classList.add('selected');
        const moves = getAllValidMoves(r, c);
        highlightMoves(moves);
      }
    }

    function getCell(r, c) {
      return board.children[r * 8 + c];
    }

    function clearSelection() {
      document.querySelectorAll('.cell').forEach(c => c.classList.remove('selected'));
    }

    function highlightMoves(moves) {
      document.querySelectorAll('.highlight-move').forEach(el => el.remove());
      moves.forEach(([r, c]) => {
        const cell = getCell(r, c);
        const hl = document.createElement('div');
        hl.className = 'highlight-move';
        cell.appendChild(hl);
      });
    }

    function updateBoard() {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          getCell(r, c).textContent = pieceIcons[boardState[r][c]] || '';
        }
      }
    }

    function opponent() {
      return currentTurn === 'w' ? 'b' : 'w';
    }

    function canMove(piece, fr, fc, tr, tc) {
      const target = boardState[tr][tc];
      if (target && target[0] === piece[0]) return false;
      const dr = tr - fr;
      const dc = tc - fc;
      const absR = Math.abs(dr);
      const absC = Math.abs(dc);

      switch (piece[1]) {
        case 'p': {
          const dir = piece[0] === 'w' ? -1 : 1;
          if (dc === 0 && !target) {
            if (dr === dir || (fr === (piece[0] === 'w' ? 6 : 1) && dr === 2 * dir && !boardState[fr + dir][fc])) return true;
          } else if (absC === 1 && dr === dir && target) return true;
          return false;
        }
        case 'r': return (dr === 0 || dc === 0) && clear(fr, fc, tr, tc);
        case 'b': return absR === absC && clear(fr, fc, tr, tc);
        case 'q': return (dr === 0 || dc === 0 || absR === absC) && clear(fr, fc, tr, tc);
        case 'k': return absR <= 1 && absC <= 1;
        case 'n': return (absR === 2 && absC === 1) || (absR === 1 && absC === 2);
      }
      return false;
    }

    function clear(fr, fc, tr, tc) {
      const stepR = Math.sign(tr - fr);
      const stepC = Math.sign(tc - fc);
      let r = fr + stepR, c = fc + stepC;
      while (r !== tr || c !== tc) {
        if (boardState[r][c]) return false;
        r += stepR;
        c += stepC;
      }
      return true;
    }

    function getAllValidMoves(r, c) {
      const moves = [];
      for(let tr=0; tr<8; tr++) {
        for(let tc=0; tc<8; tc++) {
          if(canMove(boardState[r][c], r, c, tr, tc)) {
            moves.push([tr, tc]);
          }
        }
      }
      return moves;
    }

    function isCheckmate(color) {
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          if (boardState[r][c] === color + 'k') return false;
        }
      }
      return true;
    }

    function undoMove() {
      if (aiThinking) return; // Ù„Ø§ ØªØ±Ø§Ø¬Ø¹ Ø£Ø«Ù†Ø§Ø¡ Ø­Ø±ÙƒØ© AI
      if (moveHistory.length > 0) {
        boardState = moveHistory.pop();
        currentTurn = opponent();
        updateBoard();
        turnInfo.textContent = `Ø§Ù„Ø¯ÙˆØ±: ${currentTurn === 'w' ? 'Ø§Ù„Ø£Ø¨ÙŠØ¶' : 'Ø§Ù„Ø£Ø³ÙˆØ¯'}`;
        startTimer();
      }
    }

    function toggleNightMode() {
      document.body.classList.toggle('night');
    }

    function resetGame() {
      aiThinking = false;
      setupBoard();
      moveHistory = [];
      currentTurn = 'w';
      turnInfo.textContent = `Ø§Ù„Ø¯ÙˆØ±: Ø§Ù„Ø£Ø¨ÙŠØ¶`;
      whiteTime = 300;
      blackTime = 300;
      updateTimers();
      startTimer();
    }

    function startTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (aiThinking) return; // Ù„Ø§ ÙŠÙ‚Ù„Ù„ Ø§Ù„ÙˆÙ‚Øª Ø£Ø«Ù†Ø§Ø¡ ØªÙÙƒÙŠØ± AI
        if (currentTurn === 'w') whiteTime--;
        else blackTime--;
        updateTimers();
        if (whiteTime <= 0 || blackTime <= 0) {
          clearInterval(timerInterval);
          alert(currentTurn === 'w' ? 'Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„Ø£Ø¨ÙŠØ¶!' : 'Ø§Ù†ØªÙ‡Ù‰ ÙˆÙ‚Øª Ø§Ù„Ø£Ø³ÙˆØ¯!');
        }
      }, 1000);
    }

    function updateTimers() {
      whiteTimerEl.textContent = formatTime(whiteTime);
      blackTimerEl.textContent = formatTime(blackTime);
    }

    function formatTime(s) {
      const m = Math.floor(s / 60);
      const sec = s % 60;
      return `${m.toString().padStart(2, '0')}:${sec.toString().padStart(2, '0')}`;
    }

    // AI Ø³Ù‡Ù„: Ø­Ø±ÙƒØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù…Ù† Ø§Ù„Ø­Ø±ÙƒØ§Øª Ø§Ù„Ù…Ù…ÙƒÙ†Ø©
    function makeEasyAIMove() {
      const moves = [];
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          if(boardState[r][c] && boardState[r][c][0] === 'b') {
            const validMoves = getAllValidMoves(r, c);
            validMoves.forEach(mv => moves.push({from: [r,c], to: mv}));
          }
        }
      }
      if(moves.length === 0) return; // Ù„Ø§ Ø­Ø±ÙƒØ§Øª
      const move = moves[Math.floor(Math.random() * moves.length)];
      makeMove(move.from[0], move.from[1], move.to[0], move.to[1]);
    }

    // AI ØµØ¹Ø¨: Ø­Ø±ÙƒØ© Ø­Ø³Ø¨ ØªÙ‚ÙŠÙŠÙ… Ø¨Ø³ÙŠØ· Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ù‚Ø·Ø¹ (Ù…ÙŠÙ†ÙŠÙ…Ø§ÙƒØ³ Ù…Ø¨Ø³Ø·)
    function makeHardAIMove() {
      const moves = [];
      for(let r=0; r<8; r++) {
        for(let c=0; c<8; c++) {
          if(boardState[r][c] && boardState[r][c][0] === 'b') {
            const validMoves = getAllValidMoves(r, c);
            validMoves.forEach(mv => moves.push({from: [r,c], to: mv}));
          }
        }
      }
      if(moves.length ===

<!DOCTYPE html>
<html lang="ar">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>شطرنج سوداني - تصميم أحمد جلال ÂĜ</title>
  <link href="https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
  <style>
    :root {
      --light-square: #f0d9b5;
      --dark-square: #b58863;
      --selected: #ffcc00;
      --hint: rgba(0, 255, 0, 0.3);
      --capture-hint: rgba(255, 0, 0, 0.4);
      --check: rgba(255, 0, 0, 0.7);
      --night-bg: #1a1a1a;
      --night-text: #f0f0f0;
    }
    
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    
    body {
      font-family: 'Cairo', sans-serif;
      background: linear-gradient(135deg, #8e9eab, #eef2f3);
      color: #333;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
      transition: background 0.5s ease;
    }
    
    body.night-mode {
      background: linear-gradient(135deg, #232526, #414345);
      color: var(--night-text);
    }
    
    .header {
      text-align: center;
      margin-bottom: 20px;
      width: 100%;
      max-width: 800px;
      background: rgba(255, 255, 255, 0.9);
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      border: 2px solid #b58863;
      position: relative;
    }
    
    body.night-mode .header {
      background: rgba(30, 30, 30, 0.9);
      border-color: #8d6e63;
    }
    
    h1 {
      color: #5d4037;
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }
    
    body.night-mode h1 {
      color: #d7ccc8;
    }
    
    .subtitle {
      font-size: 1.2rem;
      color: #795548;
      margin-bottom: 15px;
    }
    
    body.night-mode .subtitle {
      color: #bcaaa4;
    }
    
    .game-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      width: 100%;
      max-width: 1200px;
    }
    
    .board-section {
      flex: 1;
      min-width: 500px;
    }
    
    .info-section {
      flex: 1;
      min-width: 300px;
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .board-container {
      background: #7b5544;
      padding: 25px;
      border-radius: 20px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
      position: relative;
    }
    
    .board {
      display: grid;
      grid-template-columns: repeat(8, 65px);
      grid-template-rows: repeat(8, 65px);
      border: 4px solid #5d4037;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);
      position: relative;
    }
    
    .cell {
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 45px;
      cursor: pointer;
      position: relative;
      user-select: none;
      transition: all 0.2s ease;
    }
    
    .light {
      background-color: var(--light-square);
    }
    
    .dark {
      background-color: var(--dark-square);
    }
    
    body.night-mode .light {
      background-color: #8d6e63;
    }
    
    body.night-mode .dark {
      background-color: #5d4037;
    }
    
    .selected {
      background-color: var(--selected);
      transform: scale(0.95);
      z-index: 10;
    }
    
    .hint {
      position: absolute;
      width: 25px;
      height: 25px;
      background-color: var(--hint);
      border-radius: 50%;
      pointer-events: none;
      z-index: 1;
    }
    
    .capture-hint {
      position: absolute;
      width: 100%;
      height: 100%;
      border: 4px solid var(--capture-hint);
      border-radius: 50%;
      pointer-events: none;
      z-index: 2;
    }
    
    .check {
      background-color: var(--check) !important;
    }
    
    .notation {
      position: absolute;
      font-size: 14px;
      color: rgba(255, 255, 255, 0.7);
      font-weight: bold;
      z-index: 3;
      pointer-events: none;
    }
    
    .file-notation {
      bottom: -20px;
      width: 65px;
      text-align: center;
    }
    
    .rank-notation {
      left: -20px;
      height: 65px;
      display: flex;
      align-items: center;
    }
    
    .game-info {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      border: 2px solid #b58863;
    }
    
    body.night-mode .game-info {
      background: rgba(30, 30, 30, 0.9);
      border-color: #8d6e63;
    }
    
    .status-card {
      margin-bottom: 20px;
      text-align: center;
    }
    
    .turn-indicator {
      font-size: 1.8rem;
      font-weight: bold;
      padding: 10px 20px;
      border-radius: 10px;
      background: #e0e0e0;
      display: inline-block;
      margin-bottom: 15px;
      box-shadow: 0 3px 5px rgba(0,0,0,0.1);
    }
    
    .white-turn {
      background: linear-gradient(to right, #f5f5f5, #e0e0e0);
      color: #333;
    }
    
    .black-turn {
      background: linear-gradient(to right, #333, #000);
      color: #fff;
    }
    
    .timer {
      font-size: 1.5rem;
      font-weight: bold;
      background: #5d4037;
      color: #fff;
      padding: 10px 15px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-bottom: 10px;
    }
    
    .game-status {
      font-size: 1.4rem;
      font-weight: bold;
      padding: 15px;
      border-radius: 10px;
      background: #f44336;
      color: white;
      text-align: center;
      display: none;
    }
    
    .check-status {
      background: #ff9800;
    }
    
    .checkmate-status {
      background: #f44336;
    }
    
    .controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 15px;
      margin-top: 20px;
    }
    
    .btn {
      padding: 12px 15px;
      font-size: 1.1rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    
    .btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 8px rgba(0,0,0,0.15);
    }
    
    .btn:active {
      transform: translateY(1px);
    }
    
    .btn-undo {
      background: linear-gradient(to right, #2196F3, #21CBF3);
      color: white;
    }
    
    .btn-night {
      background: linear-gradient(to right, #37474F, #263238);
      color: white;
    }
    
    .btn-reset {
      background: linear-gradient(to right, #f44336, #ff9800);
      color: white;
    }
    
    .btn-mode {
      background: linear-gradient(to right, #4CAF50, #8BC34A);
      color: white;
    }
    
    .mode-selector {
      margin: 15px 0;
    }
    
    select {
      width: 100%;
      padding: 12px 15px;
      font-size: 1.1rem;
      border-radius: 8px;
      border: 2px solid #b58863;
      background: #fff;
      font-weight: bold;
      cursor: pointer;
    }
    
    body.night-mode select {
      background: #333;
      color: #fff;
      border-color: #8d6e63;
    }
    
    .rules {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
      border: 2px solid #b58863;
      margin-top: 20px;
    }
    
    body.night-mode .rules {
      background: rgba(30, 30, 30, 0.9);
      border-color: #8d6e63;
    }
    
    .rules h3 {
      color: #5d4037;
      margin-bottom: 15px;
      text-align: center;
      font-size: 1.5rem;
    }
    
    body.night-mode .rules h3 {
      color: #d7ccc8;
    }
    
    .rules ul {
      padding-left: 20px;
    }
    
    .rules li {
      margin-bottom: 10px;
      line-height: 1.5;
    }
    
    .footer {
      margin-top: 30px;
      text-align: center;
      color: #5d4037;
      font-size: 1.1rem;
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    body.night-mode .footer {
      color: #d7ccc8;
    }
    
    @media (max-width: 900px) {
      .game-container {
        flex-direction: column;
      }
      
      .board-section, .info-section {
        min-width: 100%;
      }
      
      .board {
        grid-template-columns: repeat(8, 11vw);
        grid-template-rows: repeat(8, 11vw);
      }
      
      .cell {
        font-size: 8vw;
      }
      
      .notation {
        font-size: 12px;
      }
      
      .file-notation {
        bottom: -18px;
      }
      
      .rank-notation {
        left: -18px;
      }
    }
    
    @media (max-width: 600px) {
      .header {
        padding: 15px;
      }
      
      h1 {
        font-size: 2rem;
      }
      
      .subtitle {
        font-size: 1rem;
      }
      
      .board-container {
        padding: 15px;
      }
      
      .controls {
        grid-template-columns: 1fr;
      }
      
      .notation {
        font-size: 10px;
      }
      
      .file-notation {
        bottom: -15px;
      }
      
      .rank-notation {
        left: -15px;
      }
    }
    
    .chess-piece {
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
      transition: transform 0.2s ease;
    }
    
    .white-piece {
      color: #f0f0f0;
    }
    
    .black-piece {
      color: #333;
    }
    
    .piece-label {
      position: absolute;
      bottom: 2px;
      right: 2px;
      font-size: 8px;
      color: rgba(0,0,0,0.4);
      pointer-events: none;
    }
    
    .captured-pieces {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      margin-top: 10px;
      min-height: 30px;
    }
    
    .captured-piece {
      font-size: 24px;
      display: inline-block;
    }
    
    .captured-title {
      font-weight: bold;
      margin-top: 10px;
      color: #5d4037;
      text-align: center;
    }
    
    body.night-mode .captured-title {
      color: #d7ccc8;
    }
  </style>
</head>
<body>
  <div class="header">
    <h1><i class="fas fa-chess"></i> شطرنج سوداني</h1>
    <div class="subtitle">تصميم: أحمد جلال ÂĜ</div>
    <div class="subtitle">الإصدار 2.0 - 2025</div>
  </div>
  
  <div class="game-container">
    <div class="board-section">
      <div class="board-container">
        <div class="board" id="chessboard"></div>
      </div>
    </div>
    
    <div class="info-section">
      <div class="game-info">
        <div class="status-card">
          <div id="turnIndicator" class="turn-indicator white-turn">
            <i class="fas fa-chess-king"></i> دور الأبيض
          </div>
          
          <div class="timer">
            <i class="fas fa-clock"></i> الأبيض: <span id="whiteTimer">05:00</span>
          </div>
          <div class="timer">
            <i class="fas fa-clock"></i> الأسود: <span id="blackTimer">05:00</span>
          </div>
          
          <div id="gameStatus" class="game-status"></div>
          
          <div class="captured-title">القطع المأخوذة:</div>
          <div class="captured-pieces" id="whiteCaptured"></div>
          <div class="captured-pieces" id="blackCaptured"></div>
        </div>
        
        <div class="mode-selector">
          <select id="gameMode">
            <option value="human">🧑 لاعب ضد لاعب</option>
            <option value="ai-easy">🤖 كمبيوتر (سهل)</option>
            <option value="ai-hard">🧠 كمبيوتر (صعب)</option>
          </select>
        </div>
        
        <div class="controls">
          <button class="btn btn-undo" onclick="undoMove()">
            <i class="fas fa-undo"></i> تراجع
          </button>
          <button class="btn btn-night" onclick="toggleNightMode()">
            <i class="fas fa-moon"></i> وضع الليل
          </button>
          <button class="btn btn-reset" onclick="resetGame()">
            <i class="fas fa-redo"></i> إعادة اللعبة
          </button>
          <button class="btn btn-mode" onclick="toggleGameMode()">
            <i class="fas fa-exchange-alt"></i> تبديل الدور
          </button>
        </div>
      </div>
      
      <div class="rules">
        <h3><i class="fas fa-book"></i> قواعد الشطرنج السوداني</h3>
        <ul>
          <li>الحركات مثل الشطرنج الدولي مع بعض الاختلافات المحلية</li>
          <li>الملك لا يمكن أن يتحرك إلى موقف يكون فيه مهدداً</li>
          <li>عندما يكون الملك مهدداً، يجب على اللاعب حمايته</li>
          <li>اللعبة تنتهي عند كش ملك (عندما لا يمكن حماية الملك)</li>
          <li>التبييت مسموح به في ظل شروط محددة</li>
          <li>الترقية: عند وصول البيدق إلى الطرف الآخر يصبح ملكة</li>
        </ul>
      </div>
    </div>
  </div>
  
  <div class="footer">
    <div>صنع بكل ❤️ بواسطة أحمد جلال ÂĜ</div>
    <div>مهداة إلى حوش المنا</div>
    <div>الشطرنج السوداني © 2025</div>
  </div>

  <script>
    // Initialize game variables
    const board = document.getElementById("chessboard");
    const turnIndicator = document.getElementById("turnIndicator");
    const gameModeSelect = document.getElementById("gameMode");
    const whiteTimerEl = document.getElementById("whiteTimer");
    const blackTimerEl = document.getElementById("blackTimer");
    const gameStatusEl = document.getElementById("gameStatus");
    const whiteCapturedEl = document.getElementById("whiteCaptured");
    const blackCapturedEl = document.getElementById("blackCaptured");

    // Using Font Awesome for chess pieces for better cross-browser compatibility
    const pieceIcons = {
      'wp': '<i class="fas fa-chess-pawn"></i>',
      'wr': '<i class="fas fa-chess-rook"></i>',
      'wn': '<i class="fas fa-chess-knight"></i>',
      'wb': '<i class="fas fa-chess-bishop"></i>',
      'wq': '<i class="fas fa-chess-queen"></i>',
      'wk': '<i class="fas fa-chess-king"></i>',
      'bp': '<i class="fas fa-chess-pawn"></i>',
      'br': '<i class="fas fa-chess-rook"></i>',
      'bn': '<i class="fas fa-chess-knight"></i>',
      'bb': '<i class="fas fa-chess-bishop"></i>',
      'bq': '<i class="fas fa-chess-queen"></i>',
      'bk': '<i class="fas fa-chess-king"></i>'
    };

    // Piece labels for better identification
    const pieceLabels = {
      'wp': 'ب',
      'wr': 'ر',
      'wn': 'ح',
      'wb': 'ف',
      'wq': 'م',
      'wk': 'ك',
      'bp': 'ب',
      'br': 'ر',
      'bn': 'ح',
      'bb': 'ف',
      'bq': 'م',
      'bk': 'ك'
    };

    // Initial board setup
    const initialBoard = [
      ['br','bn','bb','bq','bk','bb','bn','br'],
      ['bp','bp','bp','bp','bp','bp','bp','bp'],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['wp','wp','wp','wp','wp','wp','wp','wp'],
      ['wr','wn','wb','wq','wk','wb','wn','wr']
    ];
    
    let boardState = JSON.parse(JSON.stringify(initialBoard));
    let selected = null;
    let currentTurn = 'w';
    let moveHistory = [];
    let whiteTime = 300, blackTime = 300;
    let timerInterval;
    let aiThinking = false;
    let gameActive = true;
    let kingPositions = { w: [7, 4], b: [0, 4] };
    let capturedPieces = { w: [], b: [] };
    
    // Files and ranks for notation
    const files = ['أ', 'ب', 'ج', 'د', 'هـ', 'و', 'ز', 'ح'];
    const ranks = ['٨', '٧', '٦', '٥', '٤', '٣', '٢', '١'];

    // Initialize the game
    function initGame() {
      setupBoard();
      resetTimers();
      updateTurnIndicator();
      gameStatusEl.style.display = 'none';
      updateCapturedPieces();
    }

    // Set up the chess board
    function setupBoard() {
      board.innerHTML = '';
      
      // Create notation for files (columns)
      for (let c = 0; c < 8; c++) {
        const fileNotation = document.createElement('div');
        fileNotation.className = 'notation file-notation';
        fileNotation.textContent = files[c];
        fileNotation.style.left = `${c * 65 + 32}px`;
        board.appendChild(fileNotation);
      }
      
      // Create notation for ranks (rows)
      for (let r = 0; r < 8; r++) {
        const rankNotation = document.createElement('div');
        rankNotation.className = 'notation rank-notation';
        rankNotation.textContent = ranks[r];
        rankNotation.style.top = `${r * 65 + 32}px`;
        board.appendChild(rankNotation);
      }
      
      // Create board cells
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = document.createElement('div');
          cell.className = `cell ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
          cell.dataset.row = r;
          cell.dataset.col = c;
          
          if (boardState[r][c]) {
            const piece = document.createElement('div');
            piece.className = `chess-piece ${boardState[r][c][0] === 'w' ? 'white-piece' : 'black-piece'}`;
            piece.innerHTML = pieceIcons[boardState[r][c]];
            
            // Add piece label for identification
            const label = document.createElement('div');
            label.className = 'piece-label';
            label.textContent = pieceLabels[boardState[r][c]];
            piece.appendChild(label);
            
            cell.appendChild(piece);
          }
          
          cell.onclick = () => onCellClick(r, c);
          board.appendChild(cell);
        }
      }
    }
    
    // Handle cell clicks
    function onCellClick(r, c) {
      if (!gameActive || aiThinking) return;
      
      const piece = boardState[r][c];
      const cell = getCell(r, c);
      
      // If a piece is already selected
      if (selected) {
        const [fromR, fromC] = selected;
        const selectedPiece = boardState[fromR][fromC];
        
        // Check if the move is valid
        if (isValidMove(selectedPiece, fromR, fromC, r, c)) {
          makeMove(fromR, fromC, r, c);
          return;
        }
        
        // If clicking on another piece of the same color, select that piece instead
        if (piece && piece[0] === currentTurn) {
          clearSelection();
          selectPiece(r, c);
        } else {
          clearSelection();
        }
      } 
      // Select a piece if it belongs to the current player
      else if (piece && piece[0] === currentTurn) {
        selectPiece(r, c);
      }
    }
    
    // Make a move on the board
    function makeMove(fromR, fromC, toR, toC) {
      const selectedPiece = boardState[fromR][fromC];
      const targetPiece = boardState[toR][toC];
      
      // Add captured piece to the list
      if (targetPiece) {
        capturedPieces[currentTurn].push(targetPiece);
        updateCapturedPieces();
      }
      
      // Save the move to history
      moveHistory.push({
        board: JSON.parse(JSON.stringify(boardState)),
        from: [fromR, fromC],
        to: [toR, toC],
        piece: selectedPiece,
        captured: targetPiece,
        kingPos: {...kingPositions},
        capturedPieces: JSON.parse(JSON.stringify(capturedPieces))
      });
      
      // Move the piece
      boardState[toR][toC] = selectedPiece;
      boardState[fromR][fromC] = '';
      
      // Update king position if king was moved
      if (selectedPiece[1] === 'k') {
        kingPositions[selectedPiece[0]] = [toR, toC];
      }
      
      // Pawn promotion
      if (selectedPiece[1] === 'p' && (toR === 0 || toR === 7)) {
        boardState[toR][toC] = currentTurn + 'q';
      }
      
      // Update the board display
      updateBoard();
      
      // Check if the opponent is in check
      const opponentColor = currentTurn === 'w' ? 'b' : 'w';
      const inCheck = isKingInCheck(opponentColor);
      
      // Check for checkmate or stalemate
      if (inCheck && isCheckmate(opponentColor)) {
        gameStatusEl.textContent = `كش ملك! ${currentTurn === 'w' ? 'الأبيض' : 'الأسود'} يفوز!`;
        gameStatusEl.className = 'game-status checkmate-status';
        gameStatusEl.style.display = 'block';
        gameActive = false;
        clearInterval(timerInterval);
      } else if (inCheck) {
        gameStatusEl.textContent = `${opponentColor === 'w' ? 'الأبيض' : 'الأسود'} في حالة كش!`;
        gameStatusEl.className = 'game-status check-status';
        gameStatusEl.style.display = 'block';
      } else {
        gameStatusEl.style.display = 'none';
      }
      
      // Switch turns
      currentTurn = opponentColor;
      updateTurnIndicator();
      
      // Start timer for the next player
      startTimer();
      
      // Clear selection
      clearSelection();
      
      // AI move if applicable
      if (gameModeSelect.value.startsWith('ai') && currentTurn === 'b' && gameActive) {
        aiThinking = true;
        setTimeout(() => {
          makeAIMove();
          aiThinking = false;
        }, 500);
      }
    }
    
    // Get a cell element
    function getCell(r, c) {
      return board.children[r * 8 + c + 16]; // +16 because of notation elements
    }
    
    // Clear current selection
    function clearSelection() {
      const selectedCell = document.querySelector('.selected');
      if (selectedCell) {
        selectedCell.classList.remove('selected');
      }
      document.querySelectorAll('.hint, .capture-hint').forEach(el => el.remove());
      selected = null;
    }
    
    // Select a piece and show hints
    function selectPiece(r, c) {
      selected = [r, c];
      getCell(r, c).classList.add('selected');
      showHints(r, c);
    }
    
    // Show possible moves for a piece
    function showHints(r, c) {
      const piece = boardState[r][c];
      
      for (let toR = 0; toR < 8; toR++) {
        for (let toC = 0; toC < 8; toC++) {
          if (isValidMove(piece, r, c, toR, toC)) {
            const cell = getCell(toR, toC);
            const hint = document.createElement('div');
            
            if (boardState[toR][toC]) {
              hint.className = 'capture-hint';
            } else {
              hint.className = 'hint';
            }
            
            cell.appendChild(hint);
          }
        }
      }
    }
    
    // Check if a move is valid
    function isValidMove(piece, fromR, fromC, toR, toC) {
      if (!piece) return false;
      
      const pieceType = piece[1];
      const pieceColor = piece[0];
      const targetPiece = boardState[toR][toC];
      
      // Can't capture your own pieces
      if (targetPiece && targetPiece[0] === pieceColor) return false;
      
      const dr = toR - fromR;
      const dc = toC - fromC;
      
      // Piece-specific movement rules
      switch (pieceType) {
        case 'p': // Pawn
          const direction = pieceColor === 'w' ? -1 : 1;
          
          // Move forward
          if (dc === 0 && !targetPiece) {
            // Single move
            if (toR === fromR + direction) return true;
            // Double move from starting position
            if ((fromR === 1 && pieceColor === 'b' && toR === 3 && dr === 2) ||
                (fromR === 6 && pieceColor === 'w' && toR === 4 && dr === -2)) {
              // Check if path is clear
              return boardState[fromR + direction][fromC] === '';
            }
          }
          // Capture diagonally
          if (Math.abs(dc) === 1 && toR === fromR + direction && targetPiece) {
            return true;
          }
          break;
          
        case 'r': // Rook
          if (dr !== 0 && dc !== 0) return false;
          return isPathClear(fromR, fromC, toR, toC);
          
        case 'n': // Knight
          return (Math.abs(dr) === 2 && Math.abs(dc) === 1) || 
                 (Math.abs(dr) === 1 && Math.abs(dc) === 2);
          
        case 'b': // Bishop
          if (Math.abs(dr) !== Math.abs(dc)) return false;
          return isPathClear(fromR, fromC, toR, toC);
          
        case 'q': // Queen
          if (dr !== 0 && dc !== 0 && Math.abs(dr) !== Math.abs(dc)) return false;
          return isPathClear(fromR, fromC, toR, toC);
          
        case 'k': // King
          return Math.abs(dr) <= 1 && Math.abs(dc) <= 1;
      }
      
      return false;
    }
    
    // Check if the king is in check
    function isKingInCheck(color) {
      const [kingR, kingC] = kingPositions[color];
      const opponentColor = color === 'w' ? 'b' : 'w';
      
      // Check all opponent pieces to see if they can attack the king
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const piece = boardState[r][c];
          if (piece && piece[0] === opponentColor) {
            if (isValidMove(piece, r, c, kingR, kingC)) {
              // Highlight king's square
              const kingCell = getCell(kingR, kingC);
              kingCell.classList.add('check');
              return true;
            }
          }
        }
      }
      
      // Remove check highlight if not in check
      const kingCell = document.querySelector('.check');
      if (kingCell) kingCell.classList.remove('check');
      return false;
    }
    
    // Check for checkmate
    function isCheckmate(color) {
      // First, king must be in check
      if (!isKingInCheck(color)) return false;
      
      // Try every possible move for the color to see if any move gets out of check
      for (let fromR = 0; fromR < 8; fromR++) {
        for (let fromC = 0; fromC < 8; fromC++) {
          const piece = boardState[fromR][fromC];
          if (piece && piece[0] === color) {
            for (let toR = 0; toR < 8; toR++) {
              for (let toC = 0; toC < 8; toC++) {
                if (isValidMove(piece, fromR, fromC, toR, toC)) {
                  // Simulate the move
                  const originalPiece = boardState[toR][toC];
                  const originalFrom = boardState[fromR][fromC];
                  boardState[toR][toC] = piece;
                  boardState[fromR][fromC] = '';
                  
                  // Temporarily update king position if king was moved
                  let originalKingPos;
                  if (piece[1] === 'k') {
                    originalKingPos = kingPositions[color];
                    kingPositions[color] = [toR, toC];
                  }
                  
                  // Check if king is still in check after the move
                  const stillInCheck = isKingInCheck(color);
                  
                  // Undo the move
                  boardState[fromR][fromC] = originalFrom;
                  boardState[toR][toC] = originalPiece;
                  if (piece[1] === 'k') {
                    kingPositions[color] = originalKingPos;
                  }
                  
                  // If there's a move that gets out of check, it's not checkmate
                  if (!stillInCheck) {
                    return false;
                  }
                }
              }
            }
          }
        }
      }
      
      // No legal moves found -> checkmate
      return true;
    }
    
    // Check if the path between two positions is clear
    function isPathClear(fromR, fromC, toR, toC) {
      const dr = toR - fromR;
      const dc = toC - fromC;
      const steps = Math.max(Math.abs(dr), Math.abs(dc));
      
      const stepR = dr === 0 ? 0 : dr > 0 ? 1 : -1;
      const stepC = dc === 0 ? 0 : dc > 0 ? 1 : -1;
      
      // Check each square along the path except the final one
      for (let i = 1; i < steps; i++) {
        const r = fromR + i * stepR;
        const c = fromC + i * stepC;
        if (boardState[r][c] !== '') return false;
      }
      
      return true;
    }
    
    // Update the board display
    function updateBoard() {
      // Remove check highlight
      const checkCell = document.querySelector('.check');
      if (checkCell) checkCell.classList.remove('check');
      
      for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
          const cell = getCell(r, c);
          cell.innerHTML = '';
          cell.className = `cell ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
          
          if (boardState[r][c]) {
            const piece = document.createElement('div');
            piece.className = `chess-piece ${boardState[r][c][0] === 'w' ? 'white-piece' : 'black-piece'}`;
            piece.innerHTML = pieceIcons[boardState[r][c]];
            
            // Add piece label for identification
            const label = document.createElement('div');
            label.className = 'piece-label';
            label.textContent = pieceLabels[boardState[r][c]];
            piece.appendChild(label);
            
            cell.appendChild(piece);
          }
        }
      }
      
      // Highlight king if in check
      isKingInCheck(currentTurn === 'w' ? 'b' : 'w');
    }
    
    // Update captured pieces display
    function updateCapturedPieces() {
      whiteCapturedEl.innerHTML = capturedPieces.w.map(p => {
        return `<span class="captured-piece ${p[0] === 'w' ? 'black-piece' : 'white-piece'}">${pieceIcons[p]}</span>`;
      }).join('');
      
      blackCapturedEl.innerHTML = capturedPieces.b.map(p => {
        return `<span class="captured-piece ${p[0] === 'w' ? 'black-piece' : 'white-piece'}">${pieceIcons[p]}</span>`;
      }).join('');
    }
    
    // Update turn indicator
    function updateTurnIndicator() {
      if (currentTurn === 'w') {
        turnIndicator.innerHTML = '<i class="fas fa-chess-king"></i> دور الأبيض';
        turnIndicator.className = 'turn-indicator white-turn';
      } else {
        turnIndicator.innerHTML = '<i class="fas fa-chess-king"></i> دور الأسود';
        turnIndicator.className = 'turn-indicator black-turn';
      }
    }
    
    // Reset timers
    function resetTimers() {
      whiteTime = 300;
      blackTime = 300;
      whiteTimerEl.textContent = formatTime(whiteTime);
      blackTimerEl.textContent = formatTime(blackTime);
    }
    
    // Start the timer for the current player
    function startTimer() {
      clearInterval(timerInterval);
      timerInterval = setInterval(() => {
        if (currentTurn === 'w') {
          whiteTime--;
          whiteTimerEl.textContent = formatTime(whiteTime);
          if (whiteTime <= 0) {
            clearInterval(timerInterval);
            gameStatusEl.textContent = "انتهى الوقت! الأسود يفوز!";
            gameStatusEl.className = 'game-status checkmate-status';
            gameStatusEl.style.display = 'block';
            gameActive = false;
          }
        } else {
          blackTime--;
          blackTimerEl.textContent = formatTime(blackTime);
          if (blackTime <= 0) {
            clearInterval(timerInterval);
            gameStatusEl.textContent = "انتهى الوقت! الأبيض يفوز!";
            gameStatusEl.className = 'game-status checkmate-status';
            gameStatusEl.style.display = 'block';
            gameActive = false;
          }
        }
      }, 1000);
    }
    
    // Format time as MM:SS
    function formatTime(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }
    
    // Undo the last move
    function undoMove() {
      if (moveHistory.length === 0 || !gameActive) return;
      
      const lastMove = moveHistory.pop();
      boardState = lastMove.board;
      kingPositions = lastMove.kingPos;
      capturedPieces = lastMove.capturedPieces;
      
      // Switch turns back
      currentTurn = currentTurn === 'w' ? 'b' : 'w';
      
      updateBoard();
      clearSelection();
      updateTurnIndicator();
      updateCapturedPieces();
      gameStatusEl.style.display = 'none';
      gameActive = true;
      
      // Reset timers to previous state
      resetTimers();
      startTimer();
    }
    
    // Toggle night mode
    function toggleNightMode() {
      document.body.classList.toggle('night-mode');
    }
    
    // Reset the game
    function resetGame() {
      clearInterval(timerInterval);
      boardState = JSON.parse(JSON.stringify(initialBoard));
      kingPositions = { w: [7, 4], b: [0, 4] };
      currentTurn = 'w';
      moveHistory = [];
      capturedPieces = { w: [], b: [] };
      clearSelection();
      gameStatusEl.style.display = 'none';
      gameActive = true;
      
      resetTimers();
      updateBoard();
      updateTurnIndicator();
      updateCapturedPieces();
      startTimer();
    }
    
    // Toggle game mode
    function toggleGameMode() {
      const currentMode = gameModeSelect.value;
      const modes = ['human', 'ai-easy', 'ai-hard'];
      const nextMode = modes[(modes.indexOf(currentMode) + 1) % modes.length];
      gameModeSelect.value = nextMode;
    }
    
    // AI makes a move
    function makeAIMove() {
      if (!gameActive) return;
      
      const difficulty = gameModeSelect.value.split('-')[1];
      const moves = [];
      
      // Find all possible moves for black pieces
      for (let fromR = 0; fromR < 8; fromR++) {
        for (let fromC = 0; fromC < 8; fromC++) {
          const piece = boardState[fromR][fromC];
          if (piece && piece[0] === 'b') {
            for (let toR = 0; toR < 8; toR++) {
              for (let toC = 0; toC < 8; toC++) {
                if (isValidMove(piece, fromR, fromC, toR, toC)) {
                  moves.push({fromR, fromC, toR, toC});
                }
              }
            }
          }
        }
      }
      
      // Select a move based on difficulty
      if (moves.length > 0) {
        let move;
        if (difficulty === 'easy' || Math.random() < 0.7) {
          // Random move for easy mode or sometimes in hard mode
          move = moves[Math.floor(Math.random() * moves.length)];
        } else {
          // Prefer captures in hard mode
          const captureMoves = moves.filter(m => boardState[m.toR][m.toC]);
          if (captureMoves.length > 0) {
            move = captureMoves[Math.floor(Math.random() * captureMoves.length)];
          } else {
            move = moves[Math.floor(Math.random() * moves.length)];
          }
        }
        
        // Make the selected move
        makeMove(move.fromR, move.fromC, move.toR, move.toC);
      }
    }
    
    // Initialize the game when the page loads
    window.onload = initGame;
  </script>
</body>
</html>
